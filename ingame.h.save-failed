#pragma once
#include "gamestate.h"
#include "objects.h"
#include "keydata.h"
#include "tinyxml2.h"
#include <future>

class Ingame : public GameState
{
private:

    Player * player;
    Entity * ptr_to_player = player;
    Stage * currentstage;
    Stage player_lot, player_house, forest, general_store, limbo;
    Stage * fade_stage;
    map<String,Stage*> stageList;
    vector<String> stageNames;

    GameVariables * gameVars;
    LightingSystem lightingSystem;
    WeatherSystem weatherSystem;
    ParticleSystem particleSystem;

    vector<Object*> systems;

    Entity * entity;
    Entity * ent2;
    Inventory * inventory;
    EventSystem * eventSystem;
    DialogSystem * dialogSystem;
    Cursor * cursor;
    HUD * timedisplay;
    Preview * preview;
    HealthBar healthbar;

    GUI * gui;

    bool playerAttacks = false;

    bool busy = false;
    int targetState = NOTHING;
    //vector<Entity**> drawables;
    vector<Entity*> draw_list;
public:
    //vector<int> used_ids;

    bool reserved(int id)
    {
        for(auto& e : draw_list)
            if(e)
                if(e->id == id)
                    return true;

        return false;
    }
    int newid()
    {
        int id;
        do
        {
            id = rand()%MAXIDS;
        }
        while(reserved(id));

        return id;

    }

    void remove_entity(Entity * &en)
    {
        for(auto &e : draw_list)
        {
            if(e)
                if(e->id == en->id)
                {
                    draw_list.erase(std::find(draw_list.begin(),draw_list.end(),e));
                    break;
                }
        }
        currentstage->Remove(en);
        en = NULL;
    }

    void removeNPC(NPC * &n)
    {
        for(auto &en : draw_list)
        {
            if(n)
                if(n->id == en->id)
                {
                    draw_list.erase(std::find(draw_list.begin(),draw_list.end(),n));
                    break;
                }
        }
        n = NULL;
    }
    void change_entity(Entity * &_old, Entity * _new)
    {
        int id = _old->id;
        for(auto &e : draw_list)
        {
            if(e)
                if(e->id == id)
                {
                    e=_new;
                    break;
                }
        }
        currentstage->Remove(_old);
        currentstage->Add(_new);
        _old = _new;
        _new->id = id;

        //cout << _new->leftover << endl;
    }

    vector<Dialog> dialogs;

    enum {
        CONTROL,
        DIALOG,
        GUI,
        FADE,
    };

    int gamephase;

    void AddXp(String skill, int xp)
    {
        xps[skill] += xp;
        while(xps[skill] >= levelcap(skills[skill]))
        {
            xps[skill] -= levelcap(skills[skill]);
            skills[skill]++;
            alerts.push("Levelup! Reached " + skill + " lvl " + to_string(skills[skill]));
            if(unlocks.count(skill) && unlocks[skill].size()>=skills[skill]-2)
                alerts.push(unlocks[skill][skills[skill]-2]);
        }
    }
    void Action(Entity * e, String a)
    {
        if(a == "nothing")
            return;

        if(FirstWord(a) == "move")
        {
            float angle = atof(SecondWord(a).c_str());

            int savex = e->x, savey = e->y;

            bool canMove = true;

            e->x += cos(angle);

            for(auto o : currentstage->objects)
            if(o)
            if(o->id != e->id && Intersect(o,e))
                canMove = false;

            if(!canMove)
                e->x = savex;

            savex = e->x, savey = e->y;

            e->y += sin(angle);

            canMove = true;

            /*for(int i = 0; i <= 1; i++)
            for(int j = 0; j <= 1; j++)
            if(!currentstage->IsFree(e->x/TILESIZE+i*TILESIZE,e->y/TILESIZE+j*TILESIZE))
            */
            for(auto o : currentstage->objects)
            if(o)
            if(o->id != e->id && Intersect(o,e))
                canMove = false;

            if(!canMove)
            {
                e->y = savey;
            }
        }
    }
    void RunScript(String s, Entity **e = NULL,String i="")
    {
        String fw = FirstWord(s);
        String sw = SecondWord(s);
        String tw = nWord(3,s);
        String w4 = nWord(4,s);

        cout << s << endl;

        if(fw == "script")
        {
            for(auto sc : split(s,"script"))
                RunScript(sc,e,i);
        }
        else if(fw == "gui")
        {
            gamephase = GUI;
            String sw = SecondWord(s);
            if(sw == "shop")
                gui = new GUIShopScreen(inventory,tw);
            else if(sw == "sell")
                gui = new GUISellScreen(inventory);

        }
        else if(fw == "nextday")
        {
            NextDay();
            busy = true;
            //static std::future<void> future = std::async(std::launch::async,[this]{Save();});
            //
            Save();
            //auto ff = std::async(std::launch::async,[this]{busy = false;printf("kek\n");});

        }
        else if(fw == "xp")
        {
            AddXp(sw,atoi(tw));
        }
        else if(fw == "skill")
        {
            //string tw = nWord(3,s);
            AddXp(sw,levelcap(skills[sw]));
        }
        else if(fw == "item")
        {
            int amount = 1;
            if(tw != "")
                if(atoi(tw)!=0)
                    amount = atoi(tw);

            inventory->Add(item_templates[sw],amount);
        }
        else if(fw == "consume")
        {
            inventory->Remove(i,1);
        }
        else if(fw == "delete")
        {
            if(e)
            {
                particleSystem.Add(**e,g("particle-decay"));
                remove_entity(*e);

            }
        }
        else if(fw == "change")
        {
            if(e)
            {
                Entity * _new = new Entity(object_templates[sw],(*e)->x,(*e)->y);
                change_entity(*e,_new);
            }
        }
        else if(fw == "harvest")
        {
            RunScript("script item " + sw + " " + tw + " script delete",e);
        }
        else if(fw == "attrib")
        {
            (*e)->string_attribs[sw]=tw;
        }
        else if(fw == "spawn")
        {
            NPC* npc = new NPC(npc_templates[sw],KeyData.MouseX+camera_x,KeyData.MouseY+camera_y);

            currentstage->npcs.push_back(npc);
            AddDrawable(npc);
        }
        else if(fw == "stat")
        {
            player->increaseStat(sw,atoi(tw),(is_number(w4)?atoi(w4):0));

        }
        else if(fw == "define")
        {
            gameVars->Define(sw);
        }
        else if(fw == "undef")
        {
            gameVars->Undef(sw);
        }
        else if(fw == "increment")
        {
            gameVars->Increment(sw);
        }
        else if(fw == "dialog")
        {
            gamephase = DIALOG;
            dialogSystem->Add(dialogs[atoi(sw)]);
        }
        else if(fw == "sound")
        {
            audioCommands.push(s);
        }
        else if(fw == "exit")
        {
            dead = false;
            targetState = MENU;
        }
    }
    Ingame()
    {
        gamephase = CONTROL;
    }

    bool PlaceObject(Entity * e, int x, int y)
    {
        int w = e->w/TILESIZE;
        int h = e->h/TILESIZE;

        bool canPlace = true;

        for(int i = 0 ; i < w; i++)
            for(int j = 0; j < h; j++)
            {
                if(x+i < currentstage->w && y+j < currentstage->h)
                {
                    if(currentstage->grid[x+i][y+j])
                    {
                        canPlace = false;
                        break;
                    }
                }
                else
                {
                    canPlace = false;
                    break;
                }

            }

        if(canPlace)
        {
            e->x = x*TILESIZE;
            e->y = y*TILESIZE;

            currentstage->objects.push_back(e);
            for(int i = 0 ; i < w; i++)
                for(int j = 0; j < h; j++)
                {
                    currentstage->grid[x+i][y+j]=e;
                }
        }

        return canPlace;

    }

    void Alert(String msg)
    {
        gamephase = DIALOG;
        dialogSystem->Add(Dialog(msg));
    }
    void PlaceOverride(Entity* e, int x, int y)
    {
        e->x = x*TILESIZE;
        e->y = y*TILESIZE;

        for(auto &o : currentstage->objects)
            if(o)
                if(o->x == e->x && o->y == e->y)
                {
                    remove_entity(o);
                }

        currentstage->objects.push_back(e);


        currentstage->grid[x][y]=e;
    }
    bool SpawnObject(Entity * e, int min_x, int min_y, int max_x, int max_y)
    {
        //cout << "spawning" << endl;
        vector<std::pair<int,int> > random_box;

        for(int i = min_x; i < max_x; i++)
            for(int j = min_y; j < max_y; j++)
        {
            random_box.push_back(std::make_pair(i,j));
        }

        bool success = false;

        while(!success && random_box.size() > 0)
        {
            //cout << "randoming" << endl;
            int randindex = rand()%random_box.size();

            e->x = random_box[randindex].first*TILESIZE;
            e->y = random_box[randindex].second*TILESIZE;

            success = PlaceObject(e,random_box[randindex].first,random_box[randindex].second);

            random_box.erase(random_box.begin()+randindex);
        };

        return success;
    }

    void SpawnObjects(String e, int min_x, int min_y, int max_x, int max_y, int _count)
    {
        int c = 0;
        while(c < _count && SpawnObject(new Entity(ent(e)),min_x,min_y,max_x,max_y))
        {
            c++;
        }
    }
    void Save()
    {
        using namespace tinyxml2;

        XMLDocument saveFile;

        XMLNode * pRoot = saveFile.NewElement("root");

        saveFile.InsertFirstChild(pRoot);

        XMLElement * pElement;

        auto InsertInt = [&pElement, &pRoot, &saveFile](String name, int value, XMLNode* elem)
        {
            pElement = saveFile.NewElement(name.c_str());
            pElement->SetText(value);
            elem->InsertEndChild(pElement);

        };
        auto InsertString = [&pElement, &pRoot, &saveFile](String name, String value, XMLNode* elem )
        {
            pElement = saveFile.NewElement(name.c_str());
            pElement->SetText(value.c_str());
            elem->InsertEndChild(pElement);

        };

        InsertInt("year",current_year,pRoot);

        InsertInt("season",current_season,pRoot);

        InsertInt("day",current_day,pRoot);

        InsertInt("funds",funds,pRoot);

        InsertString("player",to_string(player->x) + " " + to_string(player->y),pRoot);

        for(auto& i : inventory->toolbar)
        {
            if(i)
                InsertString("toolbar",i->name+ " " + to_string(i->quantity),pRoot);
            else
                InsertString("toolbar","blank",pRoot);
        }
        for(auto& i : inventory->items)
        {
            if(i)
                InsertString("item",i->name+ " " + to_string(i->quantity),pRoot);
            else
                InsertString("item","blank",pRoot);
        }

        ///Save skills
        XMLElement* skillsElement = saveFile.NewElement("skills");

        for(auto skill : skills)
            InsertInt(skill.first,skill.second,skillsElement);

        pRoot->InsertEndChild(skillsElement);


        ///Save stats
        XMLElement* statsElement = saveFile.NewElement("stats");

        for(auto stat : player->stat_levels)
            InsertInt(stat.first,stat.second,statsElement);

        pRoot->InsertEndChild(statsElement);

        for(auto stage : stageList)
        {

            XMLElement * stageElement = saveFile.NewElement("stage");

            InsertString("name",stage.second->name,stageElement);

            InsertString("size",to_string(stage.second->w)+" "+to_string(stage.second->h),stageElement);

            if(stage.second->indoors)
                stageElement->InsertEndChild(saveFile.NewElement("indoors"));

            fr(0,stage.second->h)
            {
                String row;
                for(int j = 0; j < stage.second->w; j++)
                    row.append(to_string(stage.second->tilemap.tile[j][i]) + " ");

                pElement = saveFile.NewElement("row");

                pElement->SetText(row.c_str());

                stageElement->InsertEndChild(pElement);
            }
            for(auto e : stage.second->objects)
            if(e && e->x < stage.second->w*TILESIZE && e->y < stage.second->h*TILESIZE)
            {
                pElement = saveFile.NewElement("object");
                auto InsertChildInt = [&pElement, &pRoot, &saveFile](String name, int value)
                {
                    XMLElement * subElement = saveFile.NewElement(name.c_str());
                    subElement->SetText(value);
                    pElement->InsertEndChild(subElement);

                };
                auto InsertChildString = [&pElement, &pRoot, &saveFile](String name, String value)
                {
                    XMLElement * subElement = saveFile.NewElement(name.c_str());
                    subElement->SetText(value.c_str());
                    pElement->InsertEndChild(subElement);

                };

                if(e->name != "")
                    InsertChildString("name",e->name);
                else
                    InsertChildString("name","door");

                InsertChildString("pos",to_string(e->x)+" "+to_string(e->y));

                XMLElement* attributes = saveFile.NewElement("attributes");

                for(auto attrib : e->int_attribs)
                {
                    XMLElement * attribute = saveFile.NewElement(attrib.first.c_str());
                    attribute->SetText(to_string(attrib.second).c_str());
                    attributes->InsertEndChild(attribute);
                }
                for(auto attrib : e->string_attribs)
                {
                    XMLElement * attribute = saveFile.NewElement(attrib.first.c_str());
                    attribute->SetText(to_string(attrib.second).c_str());
                    attributes->InsertEndChild(attribute);
                }
                if(attributes->FirstChildElement() != NULL)
                    pElement->InsertEndChild(attributes);

                stageElement->InsertEndChild(pElement);
            }

            for(auto e : stage.second->npcs)
            if(e)
            {
                printf("Saving npc..\n");
                pElement = saveFile.NewElement("npc");
                auto InsertChildInt = [&pElement, &pRoot, &saveFile](String name, int value)
                {
                    XMLElement * subElement = saveFile.NewElement(name.c_str());
                    subElement->SetText(value);
                    pElement->InsertEndChild(subElement);

                };
                auto InsertChildString = [&pElement, &pRoot, &saveFile](String name, String value)
                {
                    XMLElement * subElement = saveFile.NewElement(name.c_str());
                    subElement->SetText(value.c_str());
                    pElement->InsertEndChild(subElement);

                };

                if(e->met)
                    pElement->InsertEndChild(saveFile.NewElement("met"));

                InsertChildString("name",e->name);

                InsertChildString("pos",to_string(e->x)+" "+to_string(e->y));

                stageElement->InsertEndChild(pElement);
            }

            pRoot->InsertEndChild(stageElement);
        }
        saveFile.SaveFile("data/save/save.xml");

        busy = false;
        //saveFile.
    }
    bool LoadDialogs()
    {
        printf("Loading dialogs from XML list...\n");
        using namespace tinyxml2;

        XMLDocument xmlDoc;
        XMLError result;

        result = xmlDoc.LoadFile("data/xml/dialog.xml");

        XMLCheckResult(result);
        printf("XML file loaded..\n");

        XMLElement * pRoot = xmlDoc.FirstChildElement();
        if(pRoot == NULL)
        {
            printf("XML read error (root)\n");
            return 0;
        }
        XMLElement * pElement = pRoot->FirstChildElement();
        if(pElement == NULL)
        {
            printf("XML read error!\n");
            return 0;
        }
        int id;

        dialogs.push_back(Dialog());

        while (pElement != NULL)
        {
            printf("Loading dialog\n");

            pElement->QueryIntAttribute("id", &id);

            Dialog newitem;

            if(pElement->FirstChildElement("speaker"))
                newitem.speaker = pElement->FirstChildElement("speaker")->GetText();
            else
                newitem.speaker = "any";

            XMLElement * chainElement = pElement->FirstChildElement("chain")->FirstChildElement("text");

            while(chainElement != NULL)
            {
                newitem.chain.push_back(chainElement->GetText());

                chainElement = chainElement->NextSiblingElement("text");
            }
            if(pElement->FirstChildElement("question")!=NULL)
            {
                newitem.hasQuestion = true;
                newitem.question = pElement->FirstChildElement("question")->FirstChildElement("text")->GetText();
                chainElement = pElement->FirstChildElement("question")->FirstChildElement("response");

                while(chainElement != NULL)
                {
                    newitem.answers.push_back(chainElement->GetText());
                    int attribute;
                    chainElement->QueryIntAttribute("goto",&attribute);
                    newitem.gotos.push_back(attribute);
                    if(chainElement->Attribute("outcome")!=NULL)
                        newitem.outcomes.push_back(chainElement->Attribute("outcome"));
                    else
                    {
                        newitem.outcomes.push_back("");
                    }
                    if(chainElement->Attribute("condition")!=NULL)
                        newitem.conditions.push_back(chainElement->Attribute("condition"));
                    else
                    {
                        newitem.conditions.push_back("");
                    }
                    chainElement = chainElement->NextSiblingElement("response");
                }
            }
            dialogs.push_back(newitem);

            //item_ids[newitem.name]=id;

            pElement = pElement->NextSiblingElement("dialog");
        };

        printf("Finished loading dialogs!\n");
        return 1;
    }

    bool LoadRecipes()
    {
        printf("Loading recipes from XML list...\n");
        using namespace tinyxml2;

        XMLDocument xmlDoc;
        XMLError result;

        result = xmlDoc.LoadFile("data/xml/crafting.xml");

        XMLCheckResult(result);
        printf("XML file loaded..\n");

        XMLElement * pRoot = xmlDoc.FirstChildElement();
        if(pRoot == NULL)
        {
            printf("XML read error (root)\n");
            return 0;
        }
        XMLElement * pElement = pRoot->FirstChildElement();
        if(pElement == NULL)
        {
            printf("XML read error!\n");
            return 0;
        }
        int id;

        //item_templates.push_back(Item());

        while (pElement != NULL)
        {
            printf("Loading recipe\n");

            pElement->QueryIntAttribute("id", &id);

            CraftingRecipe newrecipe;

            newrecipe.item = pElement->FirstChildElement("item")->GetText();

            if(pElement->FirstChildElement("medium")!=NULL)
            {
                newrecipe.medium = pElement->FirstChildElement("medium")->GetText();
            }
            else
                newrecipe.medium = "";

            if(pElement->FirstChildElement("count")!=NULL)
                newrecipe.count = atoi(pElement->FirstChildElement("count")->GetText());
            else
                newrecipe.count = 1;

            if(pElement->FirstChildElement("level"))
            {
                newrecipe.level = atoi(pElement->FirstChildElement("level")->GetText());
            }
            else
            {
                newrecipe.level = 1;
            }
            if(pElement->FirstChildElement("unlock")!=NULL)
            {
                newrecipe.unlock = pElement->FirstChildElement("unlock")->GetText();
                newrecipe.unlocked = false;
            }
            else
            {
                newrecipe.unlock = "";
                newrecipe.unlocked = true;
            }
            if(pElement->FirstChildElement("skill")!=NULL)
                newrecipe.skill = pElement->FirstChildElement("skill")->GetText();
            else
                newrecipe.skill = "crafting";

            XMLElement * ingredient = pElement->FirstChildElement("ingredient");

            while(ingredient)
            {
                int _count=1;
                newrecipe.ingredients.push_back(ingredient->GetText());
                ingredient->QueryIntAttribute("count", &_count );
                if(_count)// != NULL)
                {
                    newrecipe.counts.push_back(_count);
                }
                else
                    newrecipe.counts.push_back(1);

                ingredient = ingredient->NextSiblingElement("ingredient");
            }

            recipes[newrecipe.item] = newrecipe;

            pElement = pElement->NextSiblingElement("recipe");
        };

        return 1;
    }



    bool LoadNPCs()
    {
        printf("Loading items from XML list...\n");
        using namespace tinyxml2;

        XMLDocument xmlDoc;
        XMLError result;

        result = xmlDoc.LoadFile("data/xml/npc.xml");

        XMLCheckResult(result);
        printf("XML file loaded..\n");

        XMLElement * pRoot = xmlDoc.FirstChildElement();
        if(pRoot == NULL)
        {
            printf("XML read error (root)\n");
            return 0;
        }
        XMLElement * pElement = pRoot->FirstChildElement();
        if(pElement == NULL)
        {
            printf("XML read error!\n");
            return 0;
        }
        int id;

        //npc_templates.push_back(NPC());

        while (pElement != NULL)
        {
            printf("Loading npc\n");

            pElement->QueryIntAttribute("id", &id);

            NPC newnpc;

            newnpc.name = pElement->FirstChildElement("name")->GetText();
            newnpc.fullname = pElement->FirstChildElement("fullname")->GetText();
            newnpc.img = images[ids[pElement->FirstChildElement("img")->GetText()]];
            newnpc.on_meet = atoi(pElement->FirstChildElement("onmeet")->GetText());
            newnpc.on_greet = atoi(pElement->FirstChildElement("ongreet")->GetText());
            newnpc.portrait = images[ids[pElement->FirstChildElement("portrait")->GetText()]];

            if(pElement->FirstChildElement("clipw") != NULL)
                newnpc.clipw = atoi(pElement->FirstChildElement("clipw")->GetText())*TILESIZE;
            else
                newnpc.clipw = TILESIZE;

            if(pElement->FirstChildElement("cliph") != NULL)
                newnpc.cliph = atoi(pElement->FirstChildElement("cliph")->GetText())*TILESIZE;
            else
                newnpc.cliph = TILESIZE;
            if(pElement->FirstChildElement("imgw") != NULL)
                newnpc.imgw = atoi(pElement->FirstChildElement("imgw")->GetText())*TILESIZE;
            else
                newnpc.imgw = TILESIZE;

            if(pElement->FirstChildElement("imgh") != NULL)
                newnpc.imgh = atoi(pElement->FirstChildElement("imgh")->GetText())*TILESIZE;
            else
                newnpc.imgh = TILESIZE;

            if(pElement->FirstChildElement("behaviour"))
                newnpc.behaviour=pElement->FirstChildElement("behaviour")->GetText();

            if(pElement->FirstChildElement("attributes"))
            {
                XMLElement * attrib = pElement->FirstChildElement("attributes")->FirstChildElement();
                while(attrib)
                {
                    if(attrib->GetText())
                    {
                        if(is_number(attrib->GetText()))
                            newnpc.int_attribs[attrib->Name()] = atoi(attrib->GetText());
                        else
                            newnpc.attributes[attrib->Name()] = attrib->GetText();
                    }
                    else
                        newnpc.attributes[attrib->Name()] = "1";
                    attrib = attrib->NextSiblingElement();
                }
            }

            if(pElement->FirstChildElement("animations"))
            {
                XMLElement * anim = pElement->FirstChildElement("animations")->FirstChildElement();

                while(anim)
                {
                    newnpc.alts[anim->Name()]=images[ids[anim->GetText()]];

                    anim = anim->NextSiblingElement();
                }
            }

            if(pElement->FirstChildElement("width"))
                newnpc.w = atof(pElement->FirstChildElement()->GetText())*TILESIZE;
            else
                newnpc.w = TILESIZE;

            if(pElement->FirstChildElement("height"))
                newnpc.h = atof(pElement->FirstChildElement()->GetText())*TILESIZE;
            else
                newnpc.h = TILESIZE;


            if(pElement->FirstChildElement("alt"))
                newnpc.alt = atof(pElement->FirstChildElement("alt")->GetText())*TILESIZE;
            npc_templates[newnpc.name] = newnpc;

            //npc_ids[newnpc.name]=id;

            pElement = pElement->NextSiblingElement("npc");
        };

        return 1;
    }
    bool LoadItems()
    {
        printf("Loading items from XML list...\n");
        using namespace tinyxml2;

        XMLDocument xmlDoc;
        XMLError result;

        result = xmlDoc.LoadFile("data/xml/item.xml");

        XMLCheckResult(result);
        printf("XML file loaded..\n");

        XMLElement * pRoot = xmlDoc.FirstChildElement();
        if(pRoot == NULL)
        {
            printf("XML read error (root)\n");
            return 0;
        }
        XMLElement * pElement = pRoot->FirstChildElement();
        if(pElement == NULL)
        {
            printf("XML read error!\n");
            return 0;
        }
        int id;

        //item_templates.push_back(Item());

        while (pElement != NULL)
        {
            printf("Loading item\n");

            pElement->QueryIntAttribute("id", &id);

            Item newitem;

            newitem.name = pElement->FirstChildElement("name")->GetText();
            newitem.formal = pElement->FirstChildElement("formal")->GetText();
            newitem.img = images[ids[pElement->FirstChildElement("img")->GetText()]];
            newitem.max_stack = atoi(pElement->FirstChildElement("stack")->GetText());
            newitem.category = pElement->FirstChildElement("category")->GetText();
            newitem.type = pElement->FirstChildElement("type")->GetText();
            if(pElement->FirstChildElement("desc")!=NULL)
                newitem.desc = pElement->FirstChildElement("desc")->GetText();
            else
                newitem.desc = "";
            if(pElement->FirstChildElement("place")!=NULL)
            {
                newitem.string_attribs["place"] = pElement->FirstChildElement("place")->GetText();
            }

            if(pElement->FirstChildElement("range")!=NULL)
                newitem.int_attribs["range"] = atoi(pElement->FirstChildElement("range")->GetText())*TILESIZE;
            else if(newitem.category == "tool")
                newitem.int_attribs["range"] = 2*TILESIZE;

            if(pElement->FirstChildElement("price"))
                newitem.int_attribs["price"] = atoi(pElement->FirstChildElement("price")->GetText());
            if(pElement->FirstChildElement("sell"))
                newitem.int_attribs["sell"] = atoi(pElement->FirstChildElement("sell")->GetText());

            if(pElement->FirstChildElement("attributes"))
            {
                XMLElement * listElement = pElement->FirstChildElement("attributes")->FirstChildElement();

                while(listElement)
                {
                    if(listElement->GetText())
                    {
                        if(is_number(listElement->GetText()))
                        {
                            newitem.int_attribs[listElement->Name()] = atoi(listElement->GetText());
                        }
                        else
                        {
                            newitem.string_attribs[listElement->Name()] = listElement->GetText();

                        }
                    }
                    else
                        newitem.int_attribs[listElement->Name()] = 1;
                    listElement = listElement->NextSiblingElement();
                }
            }
            //item_ids[newitem.name]=id;

            item_templates[newitem.name] = newitem;

            pElement = pElement->NextSiblingElement("item");
        };

        return 1;
    }
    void AddDrawable(Entity * e)
    {
        int id = newid();
        e->id = id;
        draw_list.push_back(e);

    }
    void SwitchStage(Stage * newstage)
    {
        cout << "Entering " << newstage->attributes["title"] << endl;

        currentstage = newstage;

        currentstage->ScanGrid();

        draw_list.clear();

        for(auto& e : currentstage->objects)
            if(e)
                AddDrawable(e);

        AddDrawable(player);
        if(player->pet){
            AddDrawable(player->pet);
            player->pet->setPos(player->x,player->y);
        }

        AddDrawable(preview);

        /*for(int i = 0; i < currentstage->npcs.size(); i++)
        {
            currentstage->ptr_to_npcs.push_back(currentstage->npcs[i]);
            drawables.push_back(&currentstage->ptr_to_npcs[i]);

        }*/
        for(auto& e : currentstage->npcs)
            if(e)
                AddDrawable(e);

        for(auto npc : currentstage->npcs)
            npc->setPlayer(player);

        std::sort(draw_list.begin(), draw_list.end(), Sorter);

        FocusCamera();

        weatherSystem.FeedClimate(currentstage->attributes["climate"]);



    }
    virtual void Init()
    {
    }
    void CreateNew()
    {

        //Load();

        LoadItems();
        LoadDialogs();
        LoadObjects();
        LoadNPCs();
        LoadRecipes();

        player = new Player(Creature(im("girl"),8*TILESIZE,6*TILESIZE,TILESIZE,TILESIZE,TILESIZE));
        ptr_to_player = player;

        setupGame();

        gamephase = DIALOG;
        dialogSystem->Add(dialogs[22]);

        inventory->Add(item_templates["axe"]);
        inventory->Add(item_templates["pickaxe"]);
        inventory->Add(item_templates["hoe"]);
        inventory->Add(item_templates["scythe"]);
        inventory->Add(item_templates["can"]);
        //inventory->Add(item_templates["apple"],30);
        //inventory->Add(item_templates["platty"]);
        //inventory->Add(item_templates["jar"],30);
        //inventory->Add(item_templates["skillbook"]);

        LoadStages();

        currentstage = (stageList["lot"]);

        for(auto npc : currentstage->npcs)
            npc->setPlayer(player);

        SwitchStage(stageList["lot"]);

    }

    void LoadStage(String stage)
    {

        cout << "Loading stage: " << stage << "\n";
        using namespace tinyxml2;

        XMLDocument doc;

        doc.LoadFile(stage.c_str());

        XMLElement * pElement = doc.FirstChildElement();

        if(pElement)
        {
            Stage * new_stage = new Stage();

            new_stage->name = pElement->FirstChildElement("name")->GetText();
            stageNames.push_back(new_stage->name);

            String sizes = pElement->FirstChildElement("size")->GetText();
            new_stage->w = new_stage->tilemap.w = atoi(FirstWord(sizes).c_str());
            new_stage->h = new_stage->tilemap.h =atoi(SecondWord(sizes).c_str());

            if(pElement->FirstChildElement("indoors"))
                new_stage->indoors = true;

            if(pElement->FirstChildElement("attributes"))
            {
                XMLElement * attribute = pElement->FirstChildElement("attributes")->FirstChildElement();

                while(attribute)
                {
                    new_stage->attributes[attribute->Name()] = attribute->GetText();

                    attribute = attribute->NextSiblingElement();
                }
            }
            XMLElement * rowElement = pElement->FirstChildElement("row");
            int height = 0;
            while(rowElement)
            {
                std::stringstream ss;

                String row = rowElement->GetText();

                ss << row;

                fr(0,new_stage->w)
                    {
                        String current;
                        ss >> current;
                        new_stage->tilemap.tile[i][height] = atoi(current);
                    }

                rowElement = rowElement->NextSiblingElement("row");
                height++;
            }

            XMLElement * objectElement = pElement->FirstChildElement("object");

            while(objectElement)
            {
                Entity * new_object;

                String name = objectElement->FirstChildElement("name")->GetText();
                String position = objectElement->FirstChildElement("pos")->GetText();

                if(name != "door")
                {
                    new_object = new Entity(object_templates[name],atoi(FirstWord(position).c_str()),atoi(SecondWord(position)));

                }
                else
                {
                    new_object = new Entity(Door("lot",atoi(FirstWord(position).c_str()),atoi(SecondWord(position))));

                }


                XMLElement* attributeElement = NULL;
                if(objectElement->FirstChildElement("attributes") != NULL)
                    attributeElement = objectElement->FirstChildElement("attributes")->FirstChildElement();

                while(attributeElement)
                {
                    String name = attributeElement->Name();
                    String value = attributeElement->GetText();

                    if(is_number(value))
                        new_object->int_attribs[name] = atoi(value);
                    else
                        new_object->string_attribs[name] = value;

                    attributeElement = attributeElement->NextSiblingElement();
                }


                new_stage->Add(new_object);
                new_stage->objects.push_back(new_object);

                objectElement = objectElement->NextSiblingElement("object");
            }
            XMLElement * npcElement = pElement->FirstChildElement("npc");

            while(npcElement)
            {
                NPC * new_object;

                String name = npcElement->FirstChildElement("name")->GetText();
                String position = npcElement->FirstChildElement("pos")->GetText();

                new_object = new NPC(npc_templates[name],atoi(FirstWord(position)),atoi(SecondWord(position).c_str()));

                if(npcElement->FirstChildElement("met"))
                    new_object->met = true;

                new_stage->npcs.push_back(new_object);


                npcElement = npcElement->NextSiblingElement("npc");
            }

            stageList[new_stage->name] = new_stage;
        }

    }
    void LoadStages()
    {
        cout << "Loading stages\n";

        vector<String> stages;

        using namespace tinyxml2;

        XMLDocument doc;

        doc.LoadFile("data/stage/list.xml");

        XMLElement * root = doc.FirstChildElement();

        if(root)
        {
            XMLElement * stageElem = root->FirstChildElement("stage");

            while(stageElem)
            {
                stages.push_back(stageElem->GetText());

                stageElem = stageElem->NextSiblingElement();

            }
        }

        for(auto stage : stages)
        {
            LoadStage("data/stage/" + stage + ".xml");
        }
    }

    bool Load()
    {
        LoadItems();
        LoadDialogs();
        LoadObjects();
        LoadNPCs();
        LoadRecipes();

        player = new Player(Creature(im("girl"),8*TILESIZE,6*TILESIZE,TILESIZE,TILESIZE));

        NPC * pet = new NPC(npc_templates["whitecat"],0,0);
        pet->sightRange=500*TILESIZE;
        pet->attackRange=2*TILESIZE;
        pet->behaviour="follow";
        pet->movement_speed=player->movement_speed;
        player->setPet(pet);

        setupGame();

        using namespace tinyxml2;

        XMLDocument xmlDoc;
        XMLError result;

        result = xmlDoc.LoadFile("data/save/save.xml");

        XMLCheckResult(result);
        printf("XML file loaded..\n");

        XMLElement * pRoot = xmlDoc.FirstChildElement();
        if(pRoot == NULL)
        {
            printf("XML read error (root)\n");
            return 0;
        }
        XMLElement * pElement = pRoot->FirstChildElement("year");
        if(pElement == NULL)
        {
            printf("XML read error!\n");
            return 0;
        }

        current_year = atoi(pElement->GetText());
        current_season = atoi(pRoot->FirstChildElement("season")->GetText());
        current_day = atoi(pRoot->FirstChildElement("day")->GetText());
        funds = atoi(pRoot->FirstChildElement("funds")->GetText());
        String player_pos = pRoot->FirstChildElement("player")->GetText();

        player->x = atoi(FirstWord(player_pos).c_str());
        player->y = atoi(SecondWord(player_pos).c_str());

        if(pRoot->FirstChildElement("stats"))
        {
            XMLElement *statElem = pRoot->FirstChildElement("stats")->FirstChildElement();
            while(statElem)
            {
                player->stats.push_back(statElem->Name());
                player->stat_levels[statElem->Name()]=atoi(statElem->GetText());
                statElem = statElem->NextSiblingElement();
            }
        }
        else
        {
            player->stats = allWord(s("player-stats"));
            for(auto s : player->stats)
                player->stat_levels[s] = 5;
        }
        pElement = pRoot->FirstChildElement("toolbar");

        int item_index = 0;


        printf("Loading inventory\n");
        while(pElement)
        {
            printf("Loading toolbar item.. \n");
            String item = pElement->GetText();

            if(item == "blank")
                inventory->toolbar[item_index] = NULL;
            else
            {

                inventory->toolbar[item_index] = new Item( item_templates[FirstWord(item)]);

                inventory->toolbar[item_index]->quantity = atoi(SecondWord(item).c_str());

            }

            pElement = pElement->NextSiblingElement("toolbar");
            item_index++;
        }
        pElement = pRoot->FirstChildElement("item");

        item_index = 0;
        while(pElement)
        {
            printf("Loading inventory item.. \n");
            String item = pElement->GetText();
            if(item == "blank")
                inventory->items[item_index] = NULL;
            else
            {
                inventory->items[item_index] = new Item(item_templates[FirstWord(item)]);

                inventory->items[item_index]->quantity = atoi(SecondWord(item).c_str());

            }


            pElement = pElement->NextSiblingElement("item");
            item_index++;
        }
        printf("Finished loading inventory \n");

        pElement = pRoot->FirstChildElement("skills");
        if(pElement)
            pElement = pElement->FirstChildElement();

        while(pElement)
        {
            skills[pElement->Name()]=atoi(pElement->GetText());
            pElement = pElement->NextSiblingElement();
        }


        pElement = pRoot->FirstChildElement("stage");
        printf("Loading stages\n");
        while(pElement)
        {
            printf("Loading stage.. \n");
            Stage * new_stage = new Stage();

            new_stage->name = pElement->FirstChildElement("name")->GetText();
            stageNames.push_back(new_stage->name);

            String sizes = pElement->FirstChildElement("size")->GetText();
            new_stage->w = new_stage->tilemap.w = atoi(FirstWord(sizes).c_str());
            new_stage->h = new_stage->tilemap.h =atoi(SecondWord(sizes).c_str());

            if(pElement->FirstChildElement("indoors"))
                new_stage->indoors = true;

            if(pElement->FirstChildElement("attributes"))
            {
                XMLElement * attribute = pElement->FirstChildElement("attributes")->FirstChildElement();

                while(attribute)
                {
                    new_stage->attributes[attribute->Name()] = attribute->GetText();

                    attribute = attribute->NextSiblingElement();
                }
            }

            XMLElement * rowElement = pElement->FirstChildElement("row");
            int height = 0;
            while(rowElement)
            {
                std::stringstream ss;

                String row = rowElement->GetText();

                ss << row;

                fr(0,new_stage->w)
                    {
                        String current;
                        ss >> current;
                        new_stage->tilemap.tile[i][height] = atoi(current);
                    }

                rowElement = rowElement->NextSiblingElement("row");
                height++;
            }

            XMLElement * objectElement = pElement->FirstChildElement("object");

            while(objectElement)
            {
                Entity * new_object;

                String name = objectElement->FirstChildElement("name")->GetText();
                String position = objectElement->FirstChildElement("pos")->GetText();

                if(name != "door")
                {
                    new_object = new Entity(object_templates[name],atoi(FirstWord(position).c_str()),atoi(SecondWord(position)));

                }
                else
                {
                    new_object = new Entity(Door("lot",atoi(FirstWord(position).c_str()),atoi(SecondWord(position))));

                }


                XMLElement* attributeElement = NULL;
                if(objectElement->FirstChildElement("attributes") != NULL)
                    attributeElement = objectElement->FirstChildElement("attributes")->FirstChildElement();

                while(attributeElement)
                {
                    String name = attributeElement->Name();
                    String value = attributeElement->GetText();

                    if(is_number(value))
                        new_object->int_attribs[name] = atoi(value);
                    else
                        new_object->string_attribs[name] = value;

                    attributeElement = attributeElement->NextSiblingElement();
                }


                new_stage->Add(new_object);
                new_stage->objects.push_back(new_object);

                objectElement = objectElement->NextSiblingElement("object");
            }
            XMLElement * npcElement = pElement->FirstChildElement("npc");

            while(npcElement)
            {
                NPC * new_object;

                String name = npcElement->FirstChildElement("name")->GetText();
                String position = npcElement->FirstChildElement("pos")->GetText();

                new_object = new NPC(npc_templates[name],atoi(FirstWord(position)),atoi(SecondWord(position).c_str()));

                if(npcElement->FirstChildElement("met"))
                    new_object->met = true;

                new_stage->npcs.push_back(new_object);


                npcElement = npcElement->NextSiblingElement("npc");
            }

            stageList[new_stage->name] = new_stage;
            pElement = pElement->NextSiblingElement("stage");

        }

        currentstage = stageList["house"];

        gamephase = DIALOG;
        dialogSystem->Add(dialogs[1]);

        fade_progress = g("fade-max");
        fade_direction = FADE_OUT;

        SwitchStage(stageList["house"]);


        printf("Done loading!\n");
        cout << "Loaded " << images.size() << " images\n";
        cout << "Loaded " << audioFiles << " audio files\n";
        cout << "Counted " << object_templates.size() << " objects\n";
        cout << "Counted " << item_templates.size() << " items\n";
        cout << "Counted " << npc_templates.size() << " NPCs\n";
        cout << "Counted " << recipes.size() << " crafting recipes\n";
        cout << "Counted " << dialogs.size() << " dialogs\n";
    }

    void setupGame()
    {
        cursor = new Cursor();
        preview = new Preview();

        inventory = new Inventory();

        eventSystem = new EventSystem;
        timedisplay = new HUD(eventSystem,player);

        lightingSystem = LightingSystem();
        particleSystem = ParticleSystem();
        weatherSystem = WeatherSystem(&particleSystem);
        systems.push_back(&particleSystem);
        systems.push_back(&weatherSystem);
        systems.push_back(&lightingSystem);

        gui = new GUIInventoryScreen();

        dialogSystem = new DialogSystem();
        gameVars = new GameVariables();
        dialogSystem->setGameVariables(gameVars);
    }
    void HandleRightClick()
    {
        bool interacted = false;

            for(auto &n : currentstage->npcs)
            {
                if(n)
                {
                    if(KeyData.MouseX+camera_x >= n->x && KeyData.MouseX+camera_x <= n->x + n->w &&
                        KeyData.MouseY+camera_y >= n->y && KeyData.MouseY+camera_y <= n->y + n->h  )
                        {
                            if(GetDistance(player->x,player->y,n->x,n->y) < globals["interact-range"])
                            {
                                eventSystem->Event("TALK");

                                gamephase = DIALOG;

                                if(n->attributes.count("behaviour-talk"))
                                {
                                    if(n->attributes["behaviour-talk"]=="random")
                                    {
                                        vector<String> lines = allWord(n->attributes["lines"]);

                                        int randomLineIndex = rand()%lines.size();

                                        dialogSystem->Add(dialogs[atoi(lines[randomLineIndex])],n->name);

                                        cout << atoi(lines[randomLineIndex]) << endl;
                                    }
                                }
                                else
                                {
                                    if(!n->met)
                                        dialogSystem->Add(dialogs[n->on_meet],n->name);
                                    else
                                        dialogSystem->Add(dialogs[n->on_greet],n->name);

                                }

                                dialogSystem->portrait = n->portrait;
                                n->met = true;
                                interacted = true;
                                break;
                            }
                        }
                }
            }
            if(!interacted)
            for(auto& e : currentstage->objects)
            {
                if(e)
                {
                    if(e->int_attribs.count("interact"))
                        if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y)&& GetDistance(player->x,player->y,e->x,e->y) < globals["interact-range"])

                    {
                        gamephase = DIALOG;

                        dialogSystem->Add(dialogs[e->int_attribs["interact"]]);

                        interacted = true;
                        break;
                    }
                    if(e->pickable)
                    {
                        if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y)&& GetDistance(player->x,player->y,e->x,e->y) < globals["interact-range"])
                        if(!inventory->IsFull())
                        {
                            /*float dx = player->x - e->x;
                            float dy = player->y - e->y;
                            float distance = sqrt(dx*dx+dy*dy);
                            */
                                inventory->Add(item_templates[e->pick]);
                                //e = NULL;
                                interacted = true;
                                particleSystem.Add(e->x,e->y,e->w,e->h,e->img,1,g("particle-decay"));
                                remove_entity(e);
                                break;

                        }
                    }
                    else if(e->type == "crafting")
                    {
                     if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y) && GetDistance(player->x,player->y,e->x,e->y) < globals["interact-range"])
                        {

                            gamephase = GUI;
                            gui = new GUICraftingScreen(inventory,e->name);
                            interacted = true;
                            break;
                        }

                    }
                    else if(e->string_attribs.count("portal"))
                    {
                        if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y) && GetDistance(player->x,player->y,e->x+e->w/2,e->y+e->h/2) < globals["interact-range"])
                        {

                            if(e->string_attribs.count("where"))
                            {
                                fade_x = atoi(FirstWord(e->string_attribs["where"]));
                                fade_y = atoi(SecondWord(e->string_attribs["where"]));
                            }
                            else
                                fade_x = fade_y = 0;

                            gamephase = FADE;
                            fade_stage = stageList[e->string_attribs["portal"]];
                            fade_direction = FADE_IN;


                            interacted = true;
                            break;
                        }
                    }

                }
            }


            if(!interacted)
                if(inventory->toolbar[inventory->selected])
                    if(inventory->toolbar[inventory->selected]->string_attribs.count("consume"))
                    {
                        RunScript(inventory->toolbar[inventory->selected]->string_attribs["consume"]);
                        inventory->Remove(inventory->selected);
                    }
                    else if(inventory->toolbar[inventory->selected]->name == "god")
                    {
                        inventory->toolbar[inventory->selected]->string_attribs["place"] = getNextEntityName();
                        preview->Add(object_templates[object_names[selectedEntity]]);
                    }
    }

    void HandleClick()
    {
        int mx = KeyData.MouseX, my = KeyData.MouseY;

        if(Contains(inventory,mx,my,0,0))
        {
            inventory->HandleClick(mx,my);
            return;
        }

        int click_x = std::floor((KeyData.MouseX+camera_x)/TILESIZE);
        int click_y = std::floor((KeyData.MouseY+camera_y)/TILESIZE);
        Item * sel = inventory->toolbar[inventory->selected];

        if(sel)
        for(auto& e : currentstage->objects)
        if(e)
        if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y))
        if(e->Interacts(sel)!=-1)
            RunScript(e->interactions[e->Interacts(sel)].script,&e,sel->name);

        if(sel){
            if(sel->string_attribs.count("place"))//category == "organic")
                    {
                        //if(inventory->toolbar[inventory->selected]->type == "seed")
                        int place_x = std::floor((KeyData.MouseX+camera_x)/TILESIZE);
                        int place_y = std::floor((KeyData.MouseY+camera_y)/TILESIZE);

                        int place_range = g("interact-range");

                        Entity * newe = new Entity(object_templates[inventory->toolbar[inventory->selected]->string_attribs["place"]],place_x*TILESIZE,place_y*TILESIZE);
                        if(GetDistance(player->x+player->w/2,player->y+player->h/2,newe->x + newe->w/2,newe->y + newe->h/2) < place_range + newe->w/2)
                        {

                            //currentstage->objects.push_back(newe);
                            if(inventory->toolbar[inventory->selected]->category != "organic" || ((!inventory->toolbar[inventory->selected]->int_attribs.count("needs_soil") && currentstage->IsGround(place_x,place_y)) || currentstage->CanPlant(place_x, place_y)))
                            if((!newe->rigid || !Intersect(newe,player)) && PlaceObject(newe,place_x,place_y))
                            {
                                particleSystem.Add(newe->x,newe->y,newe->w,newe->h,images[ids["dust"]],1,globals["particle-decay"]);
                                eventSystem->Event("PLACE",{newe->category});

                                AddDrawable(newe);

                                if(sel->name != "god")
                                    inventory->Remove(inventory->selected);

                            }
                        }
                    }
            else if(sel->category == "tool")
            {
                for(auto& e : currentstage->objects)
                //auto &e = currentstage->grid[click_x][click_y];
                    if(e)
                        //if(KeyData.MouseX+camera_x >= e->x && KeyData.MouseX+camera_x <= e->x + e->w &&
                        //       KeyData.MouseY+camera_y >= e->y && KeyData.MouseY+camera_y <= e->y + e->h  )
                        if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y)){
                            if(sel->type == "watering")
                            {
                                if(e->category == "plant" && e->int_attribs.count("needs_water"))
                                {
                                    e->int_attribs["watered"] = 1;
                                    particleSystem.Add(e->x,e->y,e->w,e->h,images[ids["water"]],1,globals["particle-decay"]);
                                    e->Shake();
                                }

                            }
                            else
                            {
                                if((e->destroy != "" || sel->name == "delete")
                                   && (sel->type == e->destroy || sel->type == "omni" || e->destroy == "any"))
                                   //&& (e->drops.size()>0 )
                                    {
                                        float dx = player->x - e->x;
                                        float dy = player->y - e->y;
                                        float distance = sqrt(dx*dx+dy*dy);

                                        int strength = 1;
                                        if(sel->int_attribs.count("strength"))
                                            strength = sel->int_attribs["strength"];

                                        if(distance < sel->int_attribs["range"])//TILESIZE*2)
                                            if(e->health <= strength)
                                            {
                                                eventSystem->Event("DESTROY", {e->name});

                                                if(sel->name != "delete")
                                                for(int i = 0; i < e->drops.size(); i++)
                                                {

                                                    int quantity =(e->maxs[i] == e->mins[i] ? e->mins[i] : rand()%(e->maxs[i]-e->mins[i])+e->mins[i]);


                                                    inventory->Add(item_templates[e->drops[i]], quantity);

                                                }

                                                particleSystem.Add(e->x,e->y,e->w,e->h,e->img,1,globals["particle-decay"]);

                                                if(e->leftover == "" || sel->name == "delete")
                                                {
                                                    remove_entity(e);
                                                    //cout << e << " " << currentstage->grid[click_x][click_y] << endl;

                                                }
                                                else
                                                {
                                                    change_entity(e,new Entity(object_templates[e->leftover],e->x,e->y));
                                                    //e = new Entity(object_templates[e->leftover],e->x,e->y);
                                                }

                                                //break;
                                            }
                                            else
                                            {
                                                e->health -= strength;
                                                e->Shake();
                                            }
                                    }
                            }
                        }

                    if(sel->type == "tilling" && (sel->name == "terra" || (currentstage->IsGround(click_x,click_y) && currentstage->IsFree(click_x,click_y) && GetDistance(player->x + player->w/2,player->y + player->h/2,KeyData.MouseX+camera_x,KeyData.MouseY+camera_y) < TILESIZE*2)))
                    {
                        particleSystem.Add(click_x*TILESIZE,click_y*TILESIZE,TILESIZE,TILESIZE,images[ids["dust"]],1,globals["particle-decay"]);
                        if(sel->name == "terra")
                            currentstage->Set(click_x,click_y,currentstage->Get(click_x,click_y)+1);
                        else
                            currentstage->Set(click_x,click_y,Stage::TILLED);
                    }
            }
            else if(sel->category == "weapon")
            {
                SwingWeapon(sel);
            }
            else if(sel->category == "organic")
            {

            }
        }

    }

    void SwingWeapon(Item* &sel)
    {
        /*if(player->moved)
            return;*/

        playerAttacks = true;

        if(sel->type == "melee" && !player->cooldown)
        {
            int iX = player->x, iY = player->y;
            switch(player->lastdir)
            {
            case LEFT:
                iX-=TILESIZE;
                break;
            case RIGHT:
                iX+=TILESIZE;
                break;
            case UP:
                iY-=TILESIZE;
                break;
            case DOWN:
                iY+=TILESIZE;
                break;
            }
            particleSystem.Add(Entity(sel->img,iX,iY,TILESIZE,TILESIZE), g("particle-decay"));

            player->setCooldown(500/sel->int_attribs["attack-speed"]);

            for(auto &n : currentstage->npcs)
            if(n)
            {

                if(Intersect(n,iX,iY,player->w,player->h) && n->int_attribs.count("health"))
                {

                    if(!n->int_attribs.count("hp"))
                    {
                        n->int_attribs["hp"]=n->int_attribs["health"];
                    }

                    String npc_name =  Capitalize(n->name);
                    cout << npc_name<< " was hit for " << sel->int_attribs["damage-min"] << " dmg!" << endl;
                    cout << npc_name << "'s health changed from " << n->int_attribs["hp"] << endl;

                    //n->int_attribs["hp"] -= sel->int_attribs["damage-min"];
                    n->Damage(sel->int_attribs["damage-min"]);
                    cout << " to " << n->int_attribs["hp"] << endl;

                    healthbar.Add(n);


                    ///PUSH NPC

                    int knockback = TILESIZE/2;
                    if(sel->int_attribs.count("knockback"))
                        knockback *= sel->int_attribs["knockback"];
                    else
                        cout << "No knockback found" << endl;
                    n->KnockBack(player->x,player->y,TILESIZE/2);

                    particleSystem.Add(n->x,n->y,n->w,n->h,n->img,true,g("particle-decay"));

                    if(n->int_attribs["hp"]<=0) ///DIED
                    {
                        cout << npc_name << " died!\n";
                        if(n->attributes.count("drops"))
                        {
                            vector<String> drops = allWord(n->attributes["drops"]);
                            int drop_index = rand()%drops.size();
                            cout << "Dropped " << drops[drop_index] << endl;

                            Entity * drop = new PickupObject(n->x+rand()%5-8,n->y+rand()%5-8,TILESIZE*3/4,TILESIZE*3/4,drops[drop_index]);
                            currentstage->objects.push_back(drop);
                            AddDrawable(drop);

                        }
                        if(n->attributes.count("ondeath"))
                        {
                            RunScript(n->attributes["ondeath"]);
                        }
                        removeNPC(n);
                    }

                    else
                    {

                    }

                }
            }
        }
        else if(sel->type=="ranged" && !player->cooldown)
        {
            float angle;
            if(player->lastdir==0)
                angle=atan2(1,0);
            else if(player->lastdir==1)
                angle=atan2(0,-1);
            else if(player->lastdir==2)
                angle=atan2(0,1);
            else
                angle=atan2(-1,0);

            float x = player->x + player->w/2;
            float y = player->y + player->h/2 - player->alt;

            particleSystem.AddPlayerProjectile(x,y,5,5,im("dark"),angle,10);

            player->setCooldown(500/sel->int_attribs["attack-speed"]);

        }
    }
    void NextDay(Stage* targetStage)
    {

        //cout << "Current day: " << current_day << endl;
        vector<Entity *> spawns;

        for(auto& e : targetStage->objects)
            if(e)
                if(e->category == "plant")
                    //if(e->type == "plant")
                    if(!e->int_attribs.count("needs_water") || (e->int_attribs.count("watered") && e->int_attribs["watered"] == 1))
                    {
                        if(e->int_attribs.count("watered") && e->int_attribs["watered"] == 1)
                            e->int_attribs["watered"]  = 0;
                        //cout << e->int_attribs["cycle"] << endl;

                        if(e->int_attribs.count("growth") && e->string_attribs.count("ripe")  )
                        {
                            e->int_attribs["growth"]++;
                            if(e->int_attribs["growth"] >= e->int_attribs["cycle"]-1)
                            {
                                //e = object_templates[e->string_attribs["ripe"]];
                                if(targetStage == currentstage)
                                    change_entity(e, new Entity(object_templates[e->string_attribs["ripe"]],e->x,e->y));
                                else
                                    e = new Entity(object_templates[e->string_attribs["ripe"]],e->x,e->y);
                            }
                        }
                    }

        for(auto& e : spawns)
        {
            targetStage->objects.push_back(e);
            if(targetStage == currentstage)
                AddDrawable(e);
        }


    }
    void NextDay()
    {

        current_day++;
        if(current_day > 30)
        {
            current_day = 1;
            current_season++;
        }
        if(current_season > 4)
        {
            current_season = 1;
            current_year++;
        }

        weatherSystem.weather = (rand()%100<globals["rain-probability"]?"rain":"none");

        for(auto& e : stageList)
            NextDay(e.second);
    }
    void FocusCamera()
    {
        /*int oldx = camera_x, oldy = camera_y;

        camera_x = (player->x - SCREEN_WIDTH/2);
        camera_y = (player->y - SCREEN_HEIGHT/2);


        if(currentstage->tilemap.w*TILESIZE > SCREEN_WIDTH && camera_x > currentstage->tilemap.w*TILESIZE-SCREEN_WIDTH/2)
            camera_x = currentstage->tilemap.w*TILESIZE-SCREEN_WIDTH/2;
        if(currentstage->tilemap.h*TILESIZE > SCREEN_HEIGHT && camera_y > currentstage->tilemap.h*TILESIZE-SCREEN_HEIGHT/2)
            camera_y = currentstage->tilemap.h*TILESIZE-SCREEN_HEIGHT/2;

        if(camera_x < -SCREEN_WIDTH/2)
            camera_x = -SCREEN_WIDTH/2;
        if(camera_y < -SCREEN_HEIGHT/2)
            camera_y = -SCREEN_HEIGHT/2;

        ///ha a map kisebb mint a kepernyo a kamera nem mozog
        if(currentstage->tilemap.w*TILESIZE < SCREEN_WIDTH)
            camera_x = currentstage->tilemap.w*TILESIZE/2-SCREEN_WIDTH/2;
        if(currentstage->tilemap.h*TILESIZE < SCREEN_HEIGHT)
            camera_y = currentstage->tilemap.h*TILESIZE/2-SCREEN_HEIGHT/2;

        camera_xvel = camera_x-oldx;
        camera_yvel = camera_y-oldy;*/

        float dX = abs(camera_x+SCREEN_WIDTH/2-player->x);
        float xDir = camera_x+SCREEN_WIDTH/2<player->x+player->w/2 ? 1 : -1;
        float dY = abs(camera_y+SCREEN_HEIGHT/2-player->y);
        float yDir = camera_y+SCREEN_HEIGHT/2<player->y+player->h/2 ? 1 : -1;

        float distance = sqrt(dX*dX+dY*dY);

        float freedom = 1*TILESIZE;
        if(abs(dX) > freedom)
        {
            camera_x+=xDir * (dX-freedom)/8;
        }
        if(abs(dY) > freedom)
            camera_y+=yDir * (dY-freedom)/8;


    }

    bool ValidatePlayer(int x, int y)
    {
        //if(currentstage->tilemap.w*TILESIZE > SCREEN_WIDTH && x > currentstage->tilemap.w*TILESIZE-SCREEN_WIDTH)
        if(x > currentstage->tilemap.w*TILESIZE-TILESIZE)
           return false;
        if(y > currentstage->tilemap.h*TILESIZE-TILESIZE)
            return false;

        if(x < 0)
            return false;
        if(y < 0)
            return false;

        return true;
    }
    void HandleMouseMove()
    {
        cursor->text = "";
        cursor->state = Cursor::NORMAL;

        preview->Move(KeyData.MouseX,KeyData.MouseY);

        if(Contains(inventory,KeyData.MouseX,KeyData.MouseY,0,0))
        {
            if((int)floor((KeyData.MouseX-inventory->x)/TILESIZE) < INVENTORY_TOOLBAR_SIZE)
            if(inventory->toolbar[(int)floor((KeyData.MouseX-inventory->x)/TILESIZE)])
                cursor->text = inventory->toolbar[(int)(KeyData.MouseX-inventory->x)/TILESIZE]->formal;
        }
        else
        {
            for(auto& e : currentstage->objects)
            if(e)
            {
                if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y))
                {
                    if(e->pickable)
                    {
                        cursor->state = Cursor::PICK;
                        cursor->text = item_templates[e->pick].formal;
                    }
                    else if(e->destroy != "")
                    {
                        cursor->state = Cursor::INTERACT;
                    }
                }
            }

            for(auto& e : currentstage->npcs)
                if(e)
                {
                    if(Contains(e,KeyData.MouseX,KeyData.MouseY,camera_x,camera_y))
                    {
                        cursor->state = Cursor::TALK;
                    }
                }
        }

    }
    void TimeTick()
    {
        current_seconds++;
        if(current_seconds > 119)
        {
            current_seconds = 0;
            current_minute++;
            if(hunger < MAX_HUNGER_LEVEL*HUNGER_SCALE-1)
                hunger++;
            if(current_minute > 59)
            {
                current_minute = 0;
                current_hour++;
                if(current_hour > 23)
                    current_hour = 0;
            }
        }

    }
    void MovePlayer()
    {

        float tempx = player->x, tempy = player->y;

        player->moved = false;

        for(int i = 0; i < abs(player->movement_speed)*2; i++)
        {
            tempx = player->x;
            tempy = player->y;

            if(i < abs(player->movement_speed))
            if(KeyData.lasth && KeyData.getKey(0))
            {
                tempx += KeyData.getDir(KeyData.lasth)*1;//player->movement_speed;
                if(KeyData.getDir(KeyData.lasth) < 0)
                    player->lastdir = 1;
                else
                    player->lastdir = 2;
                player->moved = true;
            }
            if(i >= abs(player->movement_speed))
            if(KeyData.lastv  && KeyData.getKey(1))
            {
                tempy += KeyData.getDir(KeyData.lastv)*1;//player->movement_speed;
                if(KeyData.getDir(KeyData.lastv) < 0)
                    player->lastdir = 3;
                else
                    player->lastdir = 0;
                player->moved = true;
            }
            if(KeyData.lastv  && KeyData.getKey(1) && KeyData.lasth && KeyData.getKey(0))
            {
                //player->movement_speed *= 1.5;
            }
            bool canMove = true;

            canMove = ValidatePlayer(tempx,tempy);


            if(canMove)
            for(auto& e : currentstage->objects)
            {


                    if(e)
                    {
                        int saveX = player->x;
                        int saveY = player->y;

                        player->x = tempx;
                        player->y = tempy;

                        if(Intersect(e,player))
                            //if(PixelPerfect(e,player))
                        {
                            if(e->rigid)
                                canMove = false;
                            else
                            {
                                if(player->x != saveX || player->y != saveY)
                                    if(e->category == "plant")
                                        e->Shake(0);

                            }
                        }


                        player->x = saveX;
                        player->y = saveY;

                    }
                //}

            }
            //if(currentstage->tilemap.tile[tempx/TILESIZE][tempy/TILESIZE] == 0)
            for(int i = 0 ; i < 2; i++)
                for(int j = 0; j < 2; j++)
                {
                    int gridx = std::floor((tempx+i*player->w)/TILESIZE);
                    int gridy = std::floor((tempy+j*player->h)/TILESIZE);

                    if(currentstage->IsSolid(gridx,gridy))
                        canMove = false;

                }
            if(canMove)
            {
                player->x = tempx;
                player->y = tempy;
            }
        }
        if(player->moved)
        {
            int psize = globals["particle-size"];
            image targetParticle = images[ids[(currentstage->IsGround(player->x/TILESIZE,player->y/TILESIZE)?"particle_grass":"dust")]];
            particleSystem.Add(player->x+player->w/2-psize/2,player->y+player->h-psize/2,psize,psize,targetParticle);
            player->current_frame += 0.2;
            if(player->current_frame >= g("player-anim-frames"))
                player->current_frame = 0;


            for(auto& e : currentstage->objects)
            {
                if(e && e->alt > 0)
                {
                    if(e->x - e->offset/2 > player->x + player->w || e->x + e->w + e->offset/2 < player->x
                        || e->y - e->alt > player->y + player->h || e->y < player->y)
                        {
                            e->fade = false;
                        }
                        else
                        {
                            e->fade = true;
                        }
                }
            }
        }

    }

    void HandleMouseWheel()
    {
        inventory->selected -= KeyData.wheel;
        if(inventory->selected < 0)
            inventory->selected = 9;

        else if(inventory->selected > 9)
            inventory->selected = 0;
        if(inventory->toolbar[inventory->selected])
        {
            if(inventory->toolbar[inventory->selected] && inventory->toolbar[inventory->selected]->string_attribs.count("place"))
            {
                preview->Add(object_templates[inventory->toolbar[inventory->selected]->string_attribs["place"]]);

            }
            else if(inventory->toolbar[inventory->selected]->type == "watering")
            {
                //preview = new Preview(ent)
                //preview->active = true;
            }
            else
                preview->Disable();
        }
        else
        {
            preview->Disable();

        }

    }
    void HandleKeys()
    {
        if(KeyData.wheel)
            HandleMouseWheel();
        if(KeyData.MouseMove)
            HandleMouseMove();
        if(KeyData.EscapePress)
        {
            gamephase = DIALOG;
            dialogSystem->Add(Prompt("Are you sure you want to quit?","exit"));
        }

        for(int i = 0; i < 10; i++)
        {
            if(KeyData.numPress[i] && stageNames.size() > i)
            {
                SwitchStage(stageList[stageNames[i]]);
                player->x = 6*TILESIZE;
                player->y = 4*TILESIZE;
                FocusCamera();
            }
        }
        if(KeyData.KPress)
        {
            NextDay();

        }
        if(KeyData.FPress)
        {
            gamephase = GUI;
            gui = new GUICraftingScreen(inventory, "");

        }
        if(KeyData.UpPress)
            current_hour++;
        if(KeyData.DownPress)
            current_hour--;
        if(KeyData.EPress)
        {
            gameVars->Print();

            gamephase = GUI;
            gui = new GUIInventoryScreen(inventory);
        }
        if(KeyData.CPress)
        {
            gamephase = GUI;
            gui = new GUICharacterScreen(player);
        }
        if(KeyData.XPress)
        {
            gamephase = GUI;
            gui = new GUISellScreen(inventory);
        }
        if(KeyData.Click)
            HandleClick();
        else if(KeyData.RightClick)
            HandleRightClick();

    }

    void UpdateControlPhase()
    {
        if(alerts.size()>0)
        {
            Alert(alerts.front());
            alerts.pop();
            return;
        }

        player->Update();

        for(auto& n : currentstage->npcs)
            if(n)
                Action(n,n->AI());


        FocusCamera();

        HandleKeys();

        if(!playerAttacks)
            MovePlayer();
        else if(!player->cooldown)
            playerAttacks=false;

        if(dead)
        {
            RunScript("dialog 48"); //DIE
        }
    }

    Entity getNextEntity()
    {
        selectedEntity++;
        if(selectedEntity >= object_names.size())
            selectedEntity = 0;

        return object_templates[object_names[selectedEntity]];
    }
    String getNextEntityName()
    {
        selectedEntity++;
        if(selectedEntity >= object_names.size())
            selectedEntity = 0;

        return object_names[selectedEntity];
    }
    void SwitchPhase(String ph)
    {
        cursor->text = "";
        cursor->img = NULL;

    }
    int Update()
    {
        if(busy)
        {
            cursor->Update();
            return NOTHING;
        }

        if(gamephase == FADE || (fade_progress > 0 && gamephase == CONTROL))//gamephase == FADE)
        {
            if(fade_direction == FADE_IN)
            {
                fade_progress++;
                if(fade_progress == g("fade-max"))
                {
                    fade_direction = FADE_OUT;
                    player->x = fade_x;
                    player->y = fade_y;
                    SwitchStage(fade_stage);
                    FocusCamera();
                }
            }
            else
            {
                fade_progress--;
                if(fade_progress == 0)
                {
                    gamephase = CONTROL;

                }
            }
        }
        else if(gamephase == GUI)
        {
            UpdateGUI();
        }
        else if(gamephase == CONTROL)
        {
            UpdateControlPhase();
        }
        else if(gamephase == DIALOG)
        {
            UpdateDialog();
        }

        //player->Update();

        UpdateSystems();

        std::sort(draw_list.begin(), draw_list.end(), Sorter);

        return targetState;
    }
    void UpdateGUI()
    {
        cursor->state = Cursor::NORMAL;

        if(KeyData.wheel != 0)
            gui->Scroll(-KeyData.wheel);
        else if(KeyData.SPress)
            gui->Scroll(1);
        else if(KeyData.WPress)
            gui->Scroll(-1);
        if(KeyData.MouseMove)
        {
            gui->HandleMouseMove(KeyData.MouseX,KeyData.MouseY);
            cursor->text = "";
            if(gui->type == "inventory")
            {
                int id;
                Item* it = gui->GetClick(KeyData.MouseX,KeyData.MouseY,id);

                if(it)
                    cursor->text = it->formal;
            }
            if(gui->type == "shop")
            {
                if(Contains(gui,KeyData.MouseX,KeyData.MouseY,0,0))
                {
                    /*int id = -1;
                    Item* i = gui->GetClick(KeyData.MouseX,KeyData.MouseY,id);
                    if(i)
                    {
                        cursor->text = "click to buy";
                    }*/
                }

            }
            if(gui->type == "sell")
            {
                if(Contains(gui,KeyData.MouseX,KeyData.MouseY,0,0))
                {
                    //printf("szia\n");
                    int id = -1;
                    Item* i = gui->GetClick(KeyData.MouseX,KeyData.MouseY,id);
                    if(i)
                    {
                        if(i->int_attribs.count("sell"))
                            cursor->text = to_string(i->int_attribs["sell"]);

                    }
                }

            }
        }
        if(KeyData.Click)
        {
            if(Contains(gui,KeyData.MouseX,KeyData.MouseY,0,0))
            {
                if(gui->type == "shop")
                {
                    /*int id;
                    Item* i = gui->GetClick(KeyData.MouseX,KeyData.MouseY,id);
                    if(i)
                    if(i->int_attribs["price"] <= funds)
                    {
                        eventSystem->Event("BUY");
                        funds -= i->int_attribs["price"];
                        inventory->Add(*i);
                    }*/
                    if(gui->HandleClick(KeyData.MouseX,KeyData.MouseY))
                    {
                        audioCommands.push("sound pop");
                        eventSystem->Event("BUY");
                    }

                }
                else if(gui->type == "sell")
                {
                    int id = -1;
                    Item* i = gui->GetClick(KeyData.MouseX,KeyData.MouseY,id);
                    if(i)
                    {
                        if(i->int_attribs.count("sell"))
                        {
                            audioCommands.push("sound pop");
                            eventSystem->Event("SELL");
                            funds += i->int_attribs["sell"];

                            inventory->Remove(id);

                        }


                    }

                }
                else if(gui->type == "crafting")
                {
                    if(gui->HandleClick(KeyData.MouseX,KeyData.MouseY))
                    {
                        eventSystem->Event("CRAFT");
                        audioCommands.push("sound pop");
                    }

                }
                else if(gui->type == "inventory")
                {
                    audioCommands.push("sound pop");
                    gui->HandleClick(KeyData.MouseX,KeyData.MouseY);

                }
            }

        }
        if(KeyData.EscapePress)
        {
            gui->Exit();
            audioCommands.push("sound pop");
            gamephase = CONTROL;

        }
    }
    bool isPlayingSound = false;
    void UpdateDialog()
    {
        //if(KeyData.Click)

        if(KeyData.EscapePress)
        {
            gamephase = CONTROL;
            audioCommands.push("stop 1");
            isPlayingSound = false;
            return;
        }
        if(!dialogSystem->finished_scroll)
        {
            dialogSystem->Scroll();
            if(!isPlayingSound)
            {
                audioCommands.push("sound typing 1");
                isPlayingSound = true;
            }
        }
        else
        {
            audioCommands.push("stop 1");
            isPlayingSound = false;
            if(KeyData.MouseMove)
            {
                if(Contains(dialogSystem,KeyData.MouseX,KeyData.MouseY,0,0))
                {
                    dialogSystem->Hover(KeyData.MouseX,KeyData.MouseY);
                }
            }
            if(KeyData.wheel && dialogSystem->finished_chain)
            {
                dialogSystem->selected_answer -= KeyData.wheel;
                if(dialogSystem->selected_answer < 0)
                    dialogSystem->selected_answer = dialogSystem->answers.size()-1;

                else if(dialogSystem->selected_answer > dialogSystem->answers.size()-1)
                    dialogSystem->selected_answer = 0;
            }
            else if(KeyData.WPress && dialogSystem->finished_chain)
            {
                dialogSystem->selected_answer -= 1;
                if(dialogSystem->selected_answer < 0)
                    dialogSystem->selected_answer = dialogSystem->answers.size()-1;

            }
            else if(KeyData.SPress && dialogSystem->finished_chain)
            {
                dialogSystem->selected_answer += 1;

                if(dialogSystem->selected_answer > dialogSystem->answers.size()-1)
                    dialogSystem->selected_answer = 0;

            }
            if(KeyData.Click || KeyData.EnterPress || KeyData.EPress)
            {
                if(!dialogSystem->finished_chain)
                {
                    if(!dialogSystem->hasQuestion && dialogSystem->currentstring == dialogSystem->chain.size()-1)
                        gamephase = CONTROL;
                    else
                        dialogSystem->Next();
                }
                else
                {
                    if(!dialogSystem->gotos[dialogSystem->selected_answer])
                    {
                        gamephase = CONTROL;
                        RunScript(dialogSystem->outcomes[dialogSystem->selected_answer]);

                    }
                    else
                    {
                        RunScript(dialogSystem->outcomes[dialogSystem->selected_answer]);
                        dialogSystem->Add(dialogs[dialogSystem->gotos[dialogSystem->selected_answer]]);

                    }
                }
            }

        }
    }
    void UpdateSystems()
    {
        cursor->Update();
        timedisplay->Update();
        fr(0,systems.size())
            systems[i]->Update();

        healthbar.Update();

    }
    void DrawSaving()
    {
        DrawImage(images[ids["fade"]],0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
        DrawString("saving game, please wait",15,15,-1,"font2");
    }
    void Draw()
    {
        //if(!currentstage->indoors)
        //    DrawImage(im("sky"),0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

        currentstage->Draw(std::trunc(camera_x),std::trunc(camera_y));

        particleSystem.Draw(std::trunc(camera_x),std::trunc(camera_y));


        for(auto e : draw_list)
        {
            if(e)
                if(OnScreen(e,camera_x,camera_y))
                    e->Draw(std::trunc(camera_x),std::trunc(camera_y));

        }


        weatherSystem.Draw();
        lightingSystem.Draw();

        //transitional fade
        DrawRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT,(float)fade_progress/g("fade-max"));

        if(dead)
            DrawImage(im("red"),0,0,SCREEN_WIDTH,SCREEN_HEIGHT,0.75);

        //GUI stuff start here
        inventory->Draw();

        healthbar.Draw();

        timedisplay->Draw();

        if(gamephase == DIALOG)
            dialogSystem->Draw();
        else if(gamephase == GUI)
        {
            DrawImage(images[ids["fade"]],0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
            gui->Draw();

        }
        if(busy)
            DrawSaving();

        cursor->Draw();

       ///Draw DEBUG
    }
};

class LoadGame : public Ingame
{
public:

    void Init()
    {
        Load();
    }
};
class CreateGame : public Ingame
{
public:

    void Init()
    {
        CreateNew();
    }
};
